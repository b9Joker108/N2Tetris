Итак, теперь, когда мы прошлись по теории секвенциальной логики и времени, можно идти дальше и начинать строить блоки памяти, необходимые нам для создания компьютера. И перед этим давайте взглянем на архитектуру фон Неймана и обратим внимание, что один из основных компонентов этой архитектуры — это "память". Когда мы говорим о памяти в компьютерном оборудовании, это слово означает много всего. Во-первых, есть основная память, образуемая памятью, входящей в состав компьютера и подключённой к его материнской плате. Эта основная память также делится на несколько разных категорий. Самая известная из них — RAM (ОЗУ), память с произвольным доступом. Есть также вторичная память, такая как жёсткие диски, карты памяти и так далее. Кроме того, существует различие между энергозависимой и энергонезависимой памятью. Например, когда вы отключаете компьютер от розетки, оперативная память полностью стирается. При этом информация на дисках, флеш-память и так далее — сохраняется, даже если компьютер не подключён к источнику питания. Так что есть и такое различие.
Play video starting at :1:25 and follow transcript1:25
ОЗУ используется для хранения как данных, с которыми работают наши программы, так и инструкций, из которых составлены сами эти программы. И мы поговорим об этой двойственности позже по ходу курса, когда речь пойдёт об архитектуре компьютера в целом.
Play video starting at :1:45 and follow transcript1:45
И ещё один комментарий, который я хочу сделать, прежде начать саму лекцию: как и в остальных случаях, при разговоре о памяти мы можем говорить о ней с физической точки зрения — как собственно создать эту память, какие технологии нам использовать, чтобы память реализовать. А также мы можем говорить о логической организации памяти. В этой лекции — и в данном курсе в целом, — мы нацелены на рассмотрение логики. И, в частности, здесь нас интересует блок ОЗУ — повторюсь, самый важный элемент основной памяти компьютера.
Play video starting at :2:25 and follow transcript2:25
Ладно. Прежде чем начать разговор об ОЗУ, мы должны вернуться назад и поговорить об элементарных структурных элементах, на основе которых строится память. Предыдущая лекция закончилась описанием того, как работает однобитный регистр. И не требуется сильно напрягать воображение, чтобы понять, что можно взять несколько таких регистров и собрать в одну группу, тем самым создав абстракцию 16-битного числа. Эту абстракцию мы называем регистром. Ширина (разрядность) регистра в общем случае является параметром. Мы обозначаем её "w". В некоторых компьютерах это 16 бит, в других компьютерах это может быть 32 или 64 бита. Оказывается, что это самый интересный параметр, поскольку всё, что мы скажем в этой лекции, справедливо для любой размерности, с которой вы можете столкнуться. Я же буду всё время использовать w = 16, потому что мы строим 16-разрядный компьютер. Но при этом потери общности не будет.
Play video starting at :3:35 and follow transcript3:35
Ещё я хотел бы сказать, что я буду часто использовать термин "состояние регистра". Фактически, этот термин был введён ещё в предыдущей лекции. Состояние — это значение, которое в настоящее время "хранится" в регистре. Точнее говоря, это значение, которое выражается работой внутренних схем регистра в настоящий момент. Мне кажется, что это более точное описание того, что происходит. При этом возникает иллюзия хранения, если угодно.
Play video starting at :4:10 and follow transcript4:10
Ну ладно. Вот перед вами регистр. Давайте взглянем на это устройство глазами пользователя. Как нам прочитать значение этого регистра? Оказывается, для этого нам нужно лишь проверить выход out. Почему? Потому что в любой момент времени выход "out" отдаёт состояние регистра. Так что если мы просто посмотрим значение на выходе out, то узнаем, что хранится в регистре на данном конкретном такте. Теперь давайте поговорим о том, как записать в регистр новое значение. Например, мы хотим, чтобы регистр с этого момента запомнил число 17. Что нам для этого нужно сделать? Мы устанавливаем это значение (скажем, 17) на вход in и выставляем бит загрузки. Когда я говорю "выставляем бит загрузки", то имею в виду, что мы подаём 1 на вход load. И вот что происходит. Состояние регистра становится равным v.
Play video starting at :5:13 and follow transcript5:13
И, начиная со следующего цикла, выход регистра будет тоже выдавать значение v. Итак, начиная со следующего такта, регистр фактически будет хранить новое значение 17. И он будет хранить это значение постоянно, пока мы не решим изменить это значение тем способом, который я только что описал. Теперь мы готовы показать вам наглядный пример работы регистра. Для этого запустим симулятор аппаратуры и покажем, как работает микросхема регистра. Для начала я загружу чип регистра из числа встроенных в симулятор. Для этого я выберу папку nand2tetris, в ней перейду в tools, а там — в builtinChips. Кстати, все мои действия вы повторить на своём компьютере. Все эти папки доступны и вам, разумеется, в том случае, если вы скачали на свой компьютер пакет nand2tetris. Итак, я выбираю папку builtinChips и открываю её. Я вижу, что в ней есть множество доступных мне встроенных схем. И все эти схемы являются частью набора микросхем компьютера Hack. То есть, это элементы, выходящие на сцену, когда мы собираем компьютерную архитектуру воедино. Одна из таких микросхем называется DRegister. Давайте загрузим встроенный DRegister в симулятор.
Play video starting at :6:55 and follow transcript6:55
Если посмотреть на её HDL-код, то этот код странноватый из-за того, что это встроенный элемент. Вам не нужно об этом беспокоиться, потому что в этом курсе вам не придётся создавать встроенные элементы. Вы будете создавать элементы на обычном HDL. Но этот код указывает, что данный элемент реализован в виде Java-класса по имени DRegister, предоставляющего функциональность 16-битного регистра. Также здесь говорится, что этот элемент тактируемый — ведь, как вы знаете, регистр принимает тактовый сигнал. И поскольку HDL включает магическое слово "CLOCKED", мы видим, как на панели инструментов симулятора появилась иконка с часами. Эти часы используются для имитации хода компьютерного времени, точнее, для имитации последовательности тактовых импульсов. Каждый раз, когда я кликаю по этой иконке с часами, выполняется одна фаза цикла. Две фазы: "тик" - "так". Тик - так, тик - так, тик - так. Тем самым я вручную двигаю время. Конечно же, я могу написать и тестовый сценарий, содержащий, например, цикл while, в котором бесконечно будет выдаваться тактовый сигнал. Или я могу сказать что-то вроде "выполни 10 000 итераций тик-так", и т.д. Но пока мы делаем всё вручную. Это обычный подход при построении и первом тестировании элемента. И поскольку этот элемент реализован классом Java, мы добавили в эту Java-реализацию множество разных удобных функций. Например, у DRegister есть графический интерфейс,
Play video starting at :9:7 and follow transcript9:07
показывающий текущее состояние, текущее содержимое этого регистра. Сейчас здесь 0, так как это значение по умолчанию. Давайте продолжим и изменим содержимое регистра на что-нибудь другое.
Play video starting at :9:26 and follow transcript9:26
Зададим регистру значение 17 — моё любимое число. Я заменяю значение входа in, 16-битное значение, — на 17. Кручу время вперёд и вижу, что ничего не происходит. Содержимое регистра остаётся 0, и выход регистра такой же. Ничего не происходит, потому что я забыл установить бит "load". Давайте перейдём к биту "load" и превратим его в 1. Затем вернёмся к таймеру и сделаем "тик".
Play video starting at :10:10 and follow transcript10:10
Теперь видим, что содержимое регистра изменилось на 17, что очень хорошо. Но выход регистра всё ещё равен 0. И это потому, что регистру требуется полный цикл на то, чтобы синхронизироваться и начать выдавать новое состояние. Давайте сделаем "-так". И действительно, я вижу, что с переходом на следующий такт выход регистра также стал 17. Теперь регистр в устойчивом состоянии, и это состояние — 17. И оно будет оставаться 17 до того момента времени, когда я решу поменять его на какое-нибудь другое.
Play video starting at :10:52 and follow transcript10:52
Следующее действие, которое мне стоит сделать — установить бит загрузки в 0. Это послужит защитой на случай, если вдруг кто-нибудь неумышленно изменит значение для этого регистра. Ничего не случится до тех пор, пока не будет выставлен бит "load". Давайте продолжим и изменим значение регистра: сейчас оно 17, а мы изменим его на 23 — ещё одно из моих любимых чисел. Итак, 23, и я установил бит загрузки в 1. Делаю "тик" — и вижу, что теперь регистр в несогласованном состоянии, потому что состояние регистра уже 23, но выход — по-прежнему 17. И мне, опять же, нужно завершить такт, чтобы регистр перешёл в устойчивое состояние. Так что я делаю "так", и теперь в регистре 23... Как состояние регистра хранит 23, так и сам регистр принял это новое значение и отдаёт на выход 23. Если теперь продолжить щёлкать по часам, то значение регистра остаётся 23. Это была демонстрация типового поведения регистра. Вернёмся к нашей лекции. Теперь, когда мы понимаем, как работают базовые структурные элементы памяти — регистры, мы можем начать группировать их, создавая настоящие модули памяти. И общая архитектура этих модулей выглядит следующим образом.
Play video starting at :12:38 and follow transcript12:38
На самом деле, я могу говорить о них на абстрактном уровне. Абстракция ОЗУ, тот способ, которым мы обычно представляем себе память, — это последовательность адресуемых регистров. Как если бы у каждого регистра был свой адрес в диапазоне от 0 до n - 1, в случае, если ОЗУ состоит из n регистров. Тут есть ещё один момент, который очень важно подчеркнуть и который сильно упрощает понимание и осознание принципа ОЗУ. А именно, то, что независимо от количества регистров в блоке ОЗУ — а там могут быть миллионы таких регистров, — в любой конкретный момент времени можно выбрать только один регистр, чтобы вести с ним работу. Все остальные регистры в этот момент в игре участия не принимают. В каждый определенный момент времени мы должны сказать, с каким регистром мы хотим работать. Какой регистр мы хотим прочитать или какой регистр хотим изменить. Мы должны сделать выбор. Мы должны определиться с адресом этого регистра. И мы делаем это, используя вход, который называем адресным. Задумайтесь над этим. Если нам нужно выбрать один из n возможных регистров, используя некий двоичный код, — сколько битов нам нужно для такого кодирования? Что ж, оказывается, что нам нужно log(n) таких битов. Например, если у нас восемь регистров, то нам нужно три бита, верно? Логарифм от 8 по основанию 2 равен 3. Таким образом, регистр №0 будет представлен кодом 000, а регистр №7 будет представлен кодом 111. И между ними будут все остальные варианты. Таким образом, длина адресного входа, которую мы на этой схеме обозначили за k, равна log(n), где n - количество регистров в этом конкретном устройстве ОЗУ. И, наконец, есть параметр w, который, как уже сказал не особо интересен. В нашем компьютере w равно 16. Но если вы хотите, мы можем задать в качестве w другое число — например, 64. И тогда всё, что будет говориться до конца этой лекции, при этом останется в силе. Таким образом, без потери общности, берём w равным 16. Наконец, я хочу напомнить, что это секвенциальный элемент. Он зависит от тактового сигнала, поэтому у нас на схеме есть маленький треугольник. Это означает, что поведение элемента синхронизируется. И это поведение определяется следующим образом. Если мы обозначим состояние выбранного регистра за M, то при load, равном 1, М получает значение со входа in, и, начиная со следующего такта, выход этого регистра также будет равным M. Если же load не равен 1, то выход регистра будет точно таким же, как и до этого. Таков общий принцип работы блока ОЗУ. Скажем несколько слов о том, как с помощью ОЗУ считывать и записывать значения. Чтобы прочитать значение конкретного регистра, требуется два действия: во-первых, установить на адресном входе ОЗУ номер или адрес нужного регистра, например, выбрать пятый регистр, или что-то вроде этого. А во-вторых, проверить значение на выходе модуля ОЗУ. Выход модуля ОЗУ построен таким образом — в смысле, внутренняя схематика его устроена таким образом, что на его выходе всегда идёт состояние выбранного регистра. Так что, в данном случае, он будет выводить состояние регистра с номером "i". Вот так мы считываем значение одного регистра из миллионов, которые могут быть в этом устройстве ОЗУ. Что насчёт записи? Запись немного посложнее. Если мы хотим что-то записать в пятый регистр (продолжая тот же пример), то нам нужно выставить на адресный вход 5, А на вход "in", например, подать 17. Мы выставляем бит "load" — и вот что происходит дальше: состояние пятого регистра станет 17, и со следующего такта ОЗУ начнёт выводить это значение. С этого момента и до следующей записи пятый регистр будет содержать значение 17. Пока мы не изменим его снова, используя ту же процедуру. Итак, мы теперь знаем, как читать и записывать значения отдельных регистров данного устройства ОЗУ.
Play video starting at :17:47 and follow transcript17:47
Теперь я бы хотел продемонстрировать пример работы ОЗУ. Мы снова запустим симулятор аппаратуры и посмотрим несколько примеров смены значений регистров с ходом времени.
Play video starting at :18:4 and follow transcript18:04
В этой демонстрации мы покажем работу устройства ОЗУ при помощи симулятора аппаратуры. Давайте откроем папку со встроенными элементами и найдём там какое-нибудь ОЗУ. У нас в наборе микросхем Hack есть несколько устройств ОЗУ. Выберем RAM8. Итак, я загружаю элемент. Этот элемент встроенный. Он идёт с графическим интерфейсом (GUI), который мы видим справа. И я могу использовать этот интерфейс, чтобы записывать в ОЗУ значения. Давайте попробуем. Я просто введу в регистры несколько произвольных значений. Мы можем оставить часть регистров равными нулю. Я просто ввожу значения. Ничего особо интересного. Вот и всё.
Play video starting at :19:9 and follow transcript19:09
Следует понимать, что я тут мухлюю. Управление ОЗУ на низком уровне происходит совсем не так. Давайте же теперь сделаем это, так сказать, правильным путём. Пусть, например, мы хотим прочитать значение регистра номер 5. Как мне прочитать содержимое регистра 5? Я перехожу к адресному входу устройства ОЗУ, и ввожу туда число 5. Пока ничего не происходит. Но если я пущу тактовый сигнал, то увижу, что выходной сигнал ОЗУ начинает выдавать значение 8373, которое и является содержимым выбранного регистра с номером 5. Если я хочу прочитать другой регистр, скажем, регистр номер 1,
Play video starting at :20:3 and follow transcript20:03
то меняю адрес на число 1, пускаю такт и вижу, что получаю содержимое регистра № 1. Как насчёт изменить содержимое некоторых из этих регистров? Допустим, я хочу установить содержимому регистра 4 значение 12. Я перехожу здесь к адресу, к адресному входу ОЗУ. Устанавливаю ему значение 4. Выставляю бит load, чтобы активировать запись. Я устанавливаю нужное мне значение на входе in — мы решили, что это будет 12. А затем я пускаю такты. На первом шаге я вижу, что внутреннее состояние регистра №4 стало равным 12, но выход ОЗУ всё ещё другой. Чтобы установить в ОЗУ новое значение, я должен завершить такт. Я делаю это и вижу, что теперь ОЗУ также выдаёт значение выбранного регистра, которым является регистр №4. Допустим, я хочу изменить другой регистр. Например, регистр №2. Зададим регистру №2 значение 17. Я иду ко входу address. Устанавливаю там 2. Иду ко входу in, меняю там значение на 17. Запускаю такты и вижу, что значение регистра №2 и правда стало 17. И что выход out ОЗУ теперь тоже выводит такое значение. Итак, это была демонстрация работы блока ОЗУ. В этом курсе мы собираемся построить семейство 16-битных схем памяти.
Play video starting at :22:10 and follow transcript22:10
У всех них будет совершенно одинаковая общая архитектура. Но детали будут немного отличаться. Вот элементы, которые мы собираемся построить. Мы построим RAM8, состоящий из 8 регистров, где длина адреса будет логарифмом от 8, что равно 3. Логарифм от 8 по основанию 2.
Play video starting at :22:37 and follow transcript22:37
RAM64 содержит 64 регистра и 6-битный адрес. Также мы создадим ОЗУ размером в 512 регистров (пол-килобайта), после чего — RAM4K и RAM16K, которые нам и потребуются в итоге для нашей компьютерной платформы Hack. Это те пять элементов, которые мы собираемся построить. И их создание будет удивительно простым, как вы убедитесь в следующей лекции. Тут встаёт резонный вопрос: зачем нам нужны эти пять элементов? Ответ довольно прост: потому что они нужны нам для создания нашего компьютера Hack.
Play video starting at :23:25 and follow transcript23:25
Ещё один интересный вопрос, который я обходил стороной: почему вообще эта память называется RAM? Ну, RAM буквально значит "память с произвольным доступом" [Random Access Memory].
Play video starting at :23:39 and follow transcript23:39
И я хотел бы в завершение этой лекции отметить,
Play video starting at :23:45 and follow transcript23:45
что, возможно, мы не проявили к этому чипу того уважения, что он заслуживает. Ведь в этом элементе происходит кое-что действительно замечательное, и вот что именно. Независимо от размера этой схемы — неважно, 8 в ней регистров, или в ней 8 миллионов регистров, — я могу выбрать любой регистр и выполнить над ним действие, затратив при этом на доступ одно и то же время, что поистине удивительно. Всё, что мне нужно сделать, — это подать адрес этого регистра на адресный вход, и — бум: этот регистр будет выбран, а все остальные регистры будут проигнорированы. Ладно, на самом деле никакого "бума", это я для драматического эффекта. Но на самом деле, происходящее весьма драматично, потому что, повторюсь, если я хочу выбрать регистр номер 5000, то мне достаточно лишь ввести 5000 и — "бум", прежний регистр становится неактуальным, а регистр номер 5000 становится активным, доступным для действий над ним. И нет разницы, сколько у меня регистров: 8 миллионов или 8 миллиардов. У меня есть простой способ произвольно выбирать любой регистр в этой конфигурации — и либо прочитать из него, либо записать в него, при одинаковом времени доступа. Так что это действительно замечательная возможность и позже по ходу этой недели вы сами реализуете эту функциональность при помощи HDL. Но прежде чем мы это сделаем, нам нужно описать ещё один элемент. Это элемент, реализующий операцию счёта. Он называется "счётчик". Он и будет темой нашей следующей лекции.