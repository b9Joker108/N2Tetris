В предыдущей лекции мы обсудили, как в секвенциальной логике вычислительных систем принято работать со временем. В этой же лекции мы поговорим о самих элементах, о тех микросхемах, которые предоставляют такие функции.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ::17 and follow transcript0:17
Давайте вспомним, с чего мы начали прошлую лекцию: мы разделили время на целочисленные такты. В каждую единицу времени t нам нужно какое-то значение, чтобы вычислить некоторую функцию, и выходное значение является функцией от предыдущего такта времени t-1. Какого рода элемент нам нужен, чтобы обеспечить такую функциональность? Этот нужный нам недостающий элемент должен хранить один бит информации, то есть, передавать один бит информации из момента времени t-1 в момент t. Вот чего нам не хватает. У нас есть уже много элементов комбинационной логики, обеспечивающие всевозможные преобразования в пределах такта. Но вот возможности передавать информацию от такта t-1 к такту t всё ещё не хватает. Если смотреть на этот элемент на том же уровне абстракции, что и дискретные временные отрезки, то в момент перехода от такта t-1 к такту t наш новый элемент должен запомнить бит.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :1:25 and follow transcript1:25
Он должен в этот момент запомнить, что произошло ранее, и перенести это значение на следующий шаг. Без этого нам не получить нужную функциональность.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :1:35 and follow transcript1:35
Это означает, что при переходе между двумя последовательными единицами времени у него должно быть состояние. Он должен запомнить текущее значение — 0 или 1. Это означает, что его реализация предполагает два различных физических состояниях.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :1:53 and follow transcript1:53
И должна быть возможность сменять каждое из этих физических состояний на другое согласно логике, определяемой предыдущим временным отрезком. А значит, элемент должен иметь возможность переключаться между этими двумя разными физическими состояниями. И элемент, способный переключаться между двумя разными состояниями, называется триггером. Он переключается на 0, а затем может переключиться на 1, и таким образом он запоминает состояние. Это не просто функция от текущего входа, у него есть внутри нечто, запоминаемое от одного отрезка времени до другого. Давайте же рассмотрим основной триггер, который вы будете использовать в данном курсе. Он называется "синхронный D-триггер". У этого триггера один вход и один выход, и он просто запоминает значение входа с предыдущего такта и выводит его в следующем.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :2:46 and follow transcript2:46
Если мы снова посмотрим на нашу временную диаграмму и допустим, что наш вход выглядит вот так: начинается со значения 1 в первом такте, а дальше переходит в 0 на тактах 2 и 3, после чего — в 1, и затем снова в 0.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :3:2 and follow transcript3:02
Если мы теперь посмотрим, что делает D-триггер, то он в каждый момент времени, выводит значение, которое было на входе в предыдущую единицу времени. На первом такте мы точно не знаем, каким будет выход, потому что мы не знаем, что произошло в предыдущей единице времени. Поэтому тут серая зона — мы попросту не знаем значение выхода. Но как только мы переходим к такту 2, мы точно знаем, каким должен быть выход. Он должен быть ровно таким же, каким был вход на первом такте. Аналогично, на такте 3 мы знаем, что он должен быть 0, потому что таким был вход на такте 2, — и так далее. В каждый момент времени мы просто получаем предыдущее поданное на вход значение сигнала, сдвинутое на один такт вправо. Вот в этом и состоит работа D-триггера.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :3:49 and follow transcript3:49
И этот один-единственный элемент даст нам всю секвенциальную логику, нужную нам в этом курсе. На нём буду основаны все необходимые виды секвенциальных схем: память, счётчики и так далее. Хочу упомянуть здесь один момент — а именно, что значит маленький треугольник, который мы видим в нижней части изображения D-триггера. Он означает, что перед нами — секвенциальный элемент, который зависит от времени. В отличие от всех предыдущих комбинационных элементов, которые у нас были, и чей выход зависит только от входов в данный момент времени, перед нами микросхема, выход которой зависит от того, что произошло ранее, от состояния, которое хранится внутри. Это единственная временная зависимость в логике. Хотя, наверное, интересно будет также отметить, что в любой физической реализации D-триггера, подразумевается, что такая реализация нуждается также в доступе к сигналу тактового генератора, упомянутому в прошлой лекции и разбивающему реальное непрерывное время на дискретные временные отрезки.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :4:51 and follow transcript4:51
Опять же, нас это не волнует, потому что мы живём в нашей абстракции дискретного времени, но, с нашей точки зрения, такое обозначение — способ запомнить, что у этой микросхемы есть состояние, и что она способна запоминать, что её выход зависит и от того, что происходило в предыдущих тактах.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :5:9 and follow transcript5:09
Теперь давайте скажем пару слов о реализации D-триггера. В этом курсе мы будем иметь дело с ним как с элементарным действием, которое дано вам в готовом виде, и не может быть изготовлено на основе чего-то ещё. Вы просто используете его, точно так же, как вентиль И-НЕ. На основе предлагаемых D-триггера и вентиля И-НЕ вы строите всё остальное в этом курсе. Во многих других курсах вам предлагается последовать примеру большинства реальных устройств: непосредственно построить триггер из вентилей И-НЕ. Там вы берёте их и соединяете в своеобразную петлю. Эта петля, по сути, усиливает свой же сигнал и позволяет удерживать состояние 0 или 1. А с помощью дополнительной логики вы также получаете возможность управлять состоянием извне.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :6:1 and follow transcript6:01
Такая логика обычно состоит из двух шагов. Первый шаг, как я только что описал, содержит цикл, позволяющий запоминать информацию. А второй шаг содержит некоторую логику, которая обеспечивает изоляцию между соседними отрезками времени. В этом курсе мы не будем описывать, как это делается, хотя это крайне элегантно и красиво, но мы считаем, что это довольно запутанно. Нам не кажется, что это правильный подход к рассмотрению логических схем. Мы считаем, что эти понятия у вас в голове должны быть полностью разведены: комбинационная логика, которая выполняется мгновенно, и секвенциальная логика, где мы не хотим задумываться о том, как она устроена на нижнем уровне, на уровне комбинационных элементов. Предпочтительнее думать о ней как об отдельном элементарном блоке. Теперь, когда мы можем сохранять один бит, мы можем построить и всё остальное. И существует общая парадигма, согласно которой мы будем строить всю нашу логику в компьютере. Это будет сочетание D-триггеров, запоминающих информацию, и управления ими при помощи комбинационной логики, которую мы строили в первых двух лекциях. В частности, типовой подход — это когда есть массив D-триггеров, который представляет собой всю память нашей системы.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :7:18 and follow transcript7:18
Их выходы подаются на некую комбинационную логику вместе с новым значением входа, задаваемым в текущем такте. И всё это вместе меняет состояние, которое мы сохраним на триггерах для следующего такта. Это общий подход, в соответствии с которым мы и будем всё строить, будь то память или счётчик. Например, если это счётчик, мы в этих триггерах будем хранить число, а комбинационная логика будет добавлять к счётчику единицу. Таким образом, в каждую единицу времени новое значение будет на 1 больше, чем в предыдущую единицу.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :7:50 and follow transcript7:50
Давай теперь рассмотрим наше первое устройство, первую микросхему, которую мы построим при помощи D-триггера. Это будет устройство, запоминающее бит "навсегда". D-триггер обеспечил нам основу в виде запоминания бита на один временной интервал. Если же мы хотим создать память, нам нужен какой-то способ запомнить бит навсегда. Мы сохраняем его, даём команду: начиная с данного момента помнить этот бит, — и устройство продолжает помнить этот бит. Такое устройство, такой элемент описывается следующим API, следующей схемой, которую мы называем микросхемой Bit. У неё два входа: "input" и "load".
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :8:31 and follow transcript8:31
Когда мы подаём 1 на вход "load", то запоминаем значение сигнала "input" в этот момент времени. Когда вход "load" переключается в 0, мы хотим, чтобы микросхема постоянно помнила последнее значение, которое было в неё записано, и так до следующего выполнения действия "load". Так что наша логика выглядит следующим образом: если вход "load" в момент времени t-1 равен 1, то мы хотим, чтобы выход "out" в момент времени t был равен значению входа "in" на момент времени t-1. В противном случае, мы хотим в момент t сохранить на выходе прежнее значение. То есть, то же самое значение, какое было на момент времени t-1. Как же нам построить такой элемент на основе простого D-триггера? Давайте сначала посмотрим, что этот элемент должен делать. Рассмотрим два возможных значения для сигналов "load" и "in". Допустим, мы подаём сигнал записи на тактах 1 и 4, в то время как вход, скажем, на первом такте равен 1, а затем устанавливается в 0. Давайте посмотрим, что мы ожидаем на выходе этого логического элемента. В первом такте мы не знаем предыстории, так что не имеем понятия, каково значение выхода. Давайте выделим его серым цветом. Далее, так как на первом такте мы запрашивали запись, на втором такте нам хочется, чтобы выход был таким же, каким был вход на первом такте. А так как на первом такте мы подали сигнал "load", и значение "in" было равно 1, то, соответственно, выход на втором такте должен быть 1. После этого "load" на следующие 2 такта становится равным 0. Таким образом, мы хотим, чтобы выход оставался тем же, даже если вход изменится, потому что "load" теперь равен 0. Так что следующие 2 такта мы собираемся хранить значение, до тех пор, пока "load" не перейдёт в 1.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :10:34 and follow transcript10:34
Теперь обратите внимание, что каким бы ни был вход на этих двух тактах, будет ли он 0 или 1 — нет никакой разницы. В любом случае, мы не поменяем выход нашего элемента.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :10:45 and follow transcript10:45
Теперь давайте посмотрим, что произойдёт на четвёртом такте. На четвёртом такте "load" переходит в 1. Поскольку "load" теперь 1, мы снова просим загрузить значение, и загружаемым значением будет текущее значение "in", а в четвёртом такте это значение — 0. Обратите внимание, что запись мы делаем в четвёртом такте, но повлияет она на выход лишь в пятом такте, потому что выход на пятом такте должен совпадать со входом на четвёртом только в том случае, если "load" на 4 такте этого требует. Это означает, что на пятом такте наш выход переходит в 0, как и должно быть. Таков предполагаемый механизм работы 1-битного регистра. Как нам её реализовать? Как организовать проброс запоминаемого значения, чтобы оно сохранялось до тех пор, пока мы не попросим его заменить?
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :11:33 and follow transcript11:33
Вот первый, наивный подход: берём выходное значение, которое мы запомнили, и снова подадим его на вход D-триггера. Таким образом, пока мы не скажем D-триггеру загрузить новое значение, он будет просто хранить одно и то же значение — если угодно, зациклившись. Это в целом правильная мысль, но, конечно, ещё не рабочая схема. Как нам подключить сюда, как нам подать сюда настоящий вход, если мы в то же время хотим подавать выход D-триггера обратно на себя? Как реализовать такое соединение? Так что это не вполне рабочая схема. Нужно как-то сочетать два возможных источника входа на D-триггер, один из которых — это выход предыдущего шага, а другой — новое значение на входе. И какой из них мы хотим подать на триггер, зависит, разумеется, от значения входа "load". Но мы с вами уже знаем, как объединить два источника в один выход: именно это делает мультиплексор. Таким образом, если мы возьмём "in" и подадим его на один вход мультиплексора, а предыдущий выход подадим на другой вход мультиплексора, а "load" используем для выбора между ними, то получим необходимую функциональность. Мы можем увидеть, как это работает, шаг за шагом. Давайте попробуем последовать этой реализации и в реальном времени проверить её работу. Опять же, давайте возьмём два варианта возможных сигналов, подаваемых на вход, не важно, из какого источника, и посмотрим, что делает наша реализация, когда на неё подаются эти два сигнала, и что получается на выходе. Начнём с временного шага 1. На этом шаге нам не хватает одного кусочка информации: мы не знаем, каким было предыдущее состояние D-триггера, предыдущее значение "out", ведь оно не указано в этом примере. Так что оно отмечено знаком вопроса. Все остальные значения мы можем заполнить. Мы знаем, что "in" равно 1, потому что мы это видим на диаграмме. Мы знаем, что "load" равно 1, и так далее. Теперь обратите внимание на мультиплексор: поскольку "load" равно 1 и "in" равно 1, то хоть мы и не знаем значение сигнала на другом входе, на нижнем входе мультиплексора, — мы всё равно можем с уверенностью сказать, чему равен выход мультиплексора: его выход равен 1.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :13:42 and follow transcript13:42
И тогда мы знаем, каков вход D-триггера на первом шаге. Даже несмотря на то, что мы не знаем его выход в этот момент времени, мы знаем всё о его входе. Теперь, как мы можем убедиться, всё это полностью определяет, что будет происходить на следующем шаге. На следующем шаге значение 1, которое было на входе нашего триггера, будет передано на его выход в момент перехода к следующему такту. И теперь мы можем заполнить оставшуюся информацию о том, что происходит в втором такте. Во втором такте мы знаем значение "in" — это наш вход. Также мы знаем значение "load". У нас есть предыдущее значение "out", и мы можем точно вычислить, что делает мультиплексор. Мультиплексор здесь просто берёт предыдущее выходное значение, старое значение триггера.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :14:32 and follow transcript14:32
И тогда мы снова знаем, каким будет значение входа на D-триггере. Это снова будет 1. И мы можем так продолжать шаг за шагом. В каждый момент времени мы знаем предыдущие значения: знаем значение "load", значение "in", — и можем вычислить следующее значение. И в каждый момент времени мы можем выписать значения сигналов во всех частях схемы так же, как мы делали в комбинационной логике.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :15: and follow transcript15:00
Как мы видим, эта реализация обеспечивает необходимую функциональность: всякий раз, когда на "load" подаётся высокий уровень, мы загружаем входное значение с "in" и храним его до следующей загрузки.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :15:16 and follow transcript15:16
Итак, мы рассмотрели основной компонент, позволяющий выполнять на компьютере секвенциальную логику. И мы построили на его основе первый интересный элемент — однобитную память.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| :15:31 and follow transcript15:31
Теперь, когда у нас есть однобитная память, в следующей лекции мы построим память огромного размера, содержащую множество байтов и слов.