Теперь мы в состоянии взять всё то, что узнали о теории и практике устройств памяти, — и построить элементы, реализующие все эти функции. Проект 3 берёт за основу все элементы, которые вы разработали в проектах 1 и 2, а также D-триггер, который вы можете в случае надобности использовать. С помощью этих строительных блоков вам нужно построить следующие элементы. Мы так или иначе видели в предыдущих лекциях все эти элементы. Теперь же мы их реализуем. Большинство этих элементов, за исключением счётчика команд, образуют семейство постепенно усложняющихся секвенциальных микросхем, начиная с однобитного регистра — и до ОЗУ, содержащего около 16000 регистров, 16K (16x1024) регистров. Давайте начнём с однобитного регистра. Его схема и документация показана здесь. Мы уже обсуждали его раньше. Это файл-заготовка. В нём нет ничего особенного, а реализацию Ноам описал в предыдущих лекциях. Остаётся лишь последовать описанию и создать этот чип посредством HDL. Далее мы можем взять набор таких однобитных регистров и построить из них 16-битный регистр. Здесь показан его HDL. Нужно лишь всё правильно соединить — и вы получите 16-битный регистр. Теперь мы готовы пойти дальше и создать наше первое ОЗУ, состоящее из восьми регистров. Вот API этого элемента. А вот файл-заготовка с описанием его входов и выходов. Получив всю эту информацию, давайте теперь разберёмся, как же нам построить такое ОЗУ. Тут я могу дать вам два очень важных совета. Во-первых, нужно значение с входа in и подать его одновременно, одномоментно на все восемь регистров. Вам надо посредством выражений на HDL "разветвить" это значение и подать его на все регистры в ОЗУ. Далее нужно использовать логику мультиплексора и демультиплексора, чтобы выбрать именно тот регистр, к которому нужно применить операцию чтения или записи. Повторюсь: вы рассылаете информацию во все регистры, но лишь один из них будет выбран при помощи мультиплексирования/демультиплексирования. Я не хочу вдаваться в детали, потому что, на мой взгляд, иначе ваша задача будет слишком простой. Того, что я сказал, вполне достаточно для построения данного ОЗУ. Далее, завершив построение трёх первых элементов, мы готовы к строительству более сложных элементов: RAM64, 512 и так далее по возрастанию. Так что это наша следующая задача, и вот как нам её решить: мы начинаем с микросхемы RAM8, которую мы только что обсудили, и группируем восемь таких микросхем. Получающийся результат мы называем RAM64. Мы можем взять восемь таких RAM64 и соединить их вместе, чтобы получить следующий элемент в нашей иерархии — RAM512. Мы можем сделать ещё два подобных шага, чтобы в итоге получить самый сложный элемент ОЗУ, который называется RAM16K. Мы просто рекурсивно повторяем то же самое. И, используя эту стратегию, мы можем построить все более и более сложные микросхемы ОЗУ. Как нам это сделать? Прежде всего, заметим, что устройство ОЗУ может быть построено путём группировки меньших элементов ОЗУ, описав языком HDL то, что я ранее описал на данной схеме. А адресный вход, который здесь не показан, но, как вы понимаете, он незримо присутствует... Так вот, мы можем рассматривать адресный вход каждого из этих элементов как двоичное значение, состоящее из двух логических полей. Первое поле может быть использовано для выбора той части ОЗУ, с которой вы хотите работать, а второе поле — для выбора регистра в этом ОЗУ, который вы хотите прочитать или в который нужно что-либо записать. Эти два приёма, взятые вместе, позволяют строить ОЗУ любой величины. При этом вы используете мультиплексор и демультиплексор, чтобы добиться той иерархической схемы адресации, которую я только что описал. Повторюсь, этих подсказок достаточно, чтобы вы смогли выполнить собственную реализацию на HDL. На этом всё о создании устройств ОЗУ, и мы переходим к созданию последнего элемента в этом проекте, сильно отличающегося от всех остальных. Это "счётчик команд" — причудливое название обычного счётчика. На самом деле, это название дано не просто так. Он называется счётчиком команд, потому что позже, при сборке архитектуры нашего компьютера, он будет служить в качестве счётчика команд. Но на самом деле, это попросту счётчик. У него есть входное значение, выходное значение и три управляющих бита. Полное описание поведения счётчика не такое простое. Мы обсуждали его ранее, когда говорили о счётчиках. Я хочу лишь подчеркнуть здесь четыре наиболее важных момента. Поскольку это счётчик, мы хотим устанавливать его на ноль. Нам нужна возможность задавать ему и другие значения — например, 17, 19, и т.п. Нам нужна возможность сказать ему, чтобы он начал отсчёт, на каждом такте увеличивая своё значение на 1. И в некоторых случаях мы хотим указать ему прекратить счёт, так сказать, замереть. Ваша задача — придумать правильную схему логических вентилей, реализующую эти четыре операции. Это можно сделать на основе регистра, инкрементора и ещё нескольких логических вентилей, которые мы описали ранее. Таковы ваши задачи в проекте №3. Как обычно, зайдя на сайт nand2tetris, вы найдёте там страницу проекта с массой технических подробностей. Хочу ещё раз подчеркнуть, уже в третий раз: если вы скачали себе программный пакет курса, то ничего больше скачивать не нужно. Сайт — просто для справки. На вашем компьютере уже есть все необходимые файлы в каталоге projects/03, у вас есть симулятор аппаратуры, и вы готовы работать над самостоятельным созданием всех этих микросхем. Как обычно, имеет смысл обращаться к этим ресурсам при необходимости. Наконец, те практические советы, что мы давали в предыдущем проекте, актуальны и в этом, поэтому ознакомьтесь с ними перед началом работы над проектом. Добавлю, что, как обычно, вам понадобится использовать элементы из предыдущих проектов. И, как я уже говорил ранее, лучший подход — игнорировать ваши HDL-реализации и использовать встроенные. Наконец, есть ещё один момент, который я хотел бы подчеркнуть в этом проекте: HDL-файлы этого проекта хранятся в двух отдельных папках с именами "a" и "b". И эту структуру нужно оставить в таком виде. Зачем мы так сделали? Если вы помните, наши ОЗУ
Play video starting at :9:17 and follow transcript9:17
строятся из нескольких ОЗУ поменьше. И эти меньшие элементы ОЗУ построены из ещё более мелких элементов ОЗУ, и так далее. Это как матрёшки. И если вы возьмете одно из этих огромных ОЗУ, скажем, RAM16K, и поместите его в симулятор аппаратуры, то симулятор начнёт выполнять логику элементов, рекурсивно спускаясь вниз. И так вплоть до однобитных регистров — и оказывается, симулятору аппаратуры, который является скромной программой, может потребоваться слишком много памяти, чтобы управлять слишком большим числом объектов. Поэтому, разложив регистры... извините, разложив эти микросхемы ОЗУ в два отдельных каталога, мы заставляем симулятор на определённом уровне уже не использовать HDL-файлы, а начать использовать встроенные Java-реализации. И это сделает симуляцию намного быстрее и приятнее. Поэтому, пожалуйста, просто оставьте структуру каталогов как есть. Это было описание ваших задач на проект № 3, и на этом мы, как обычно, переходим к следующей лекции, где мы дадим вам чуть более обширное представление об устройствах памяти.