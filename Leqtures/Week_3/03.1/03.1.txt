На этой неделе мы поговорим о том, как компьютеры выполняют действия поочерёдно.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| с ::11, и следуйте текстовым инструкциям0:11
В самом деле: в течение первых двух недель, мы полностью игнорировали вопрос времени. Всё происходило мгновенно: у нас были входы, и выходы моментально становились значением какой-либо функции от входов. Входы никогда не менялись, мы не предполагали никаких изменений. У нас не было никакого представления о действиях, происходящих друг за другом. Было лишь некоторое логическое отображение входов на выходы. Но, разумеется, это вовсе не то, что происходит в на самом деле. Нам нужно уметь работать с временем. Нам нужно принимать время в рассмотрение, поскольку компьютеры работают во времени. Так что нам нужно от времени? С одной стороны, есть две проблемы, которые мы хотим решить. Во-первых, нам нужна возможность использовать одну и ту же аппаратуру для разных вычислений, одно за другим. Если мы умеем складывать два числа, мы хотим использовать некоторое устройство лишь для однократного сложения двух чисел. Мы хотим использовать одно и то же оборудование для сложения чисел всякий раз, когда нам нужно сложить два числа. Нам нужно просто выполнять операции сложения друг за другом. Итак, нам нужно повторно использовать наше оборудование. Например, если взять какой-нибудь цикл в программе, этот цикл выполняет одно и то же действие многократно, и мы хотим использовать для этого одно и то же оборудование. Ещё одна важная задача, требующая понятия о времени, — помнить то, что уже было. Скажем, нам нужно помнить промежуточные результаты, или помнить, какую часть вычисления мы выполняем. Например, если у нас есть цикл, который складывает вместе 100 чисел и получает итоговую сумму, то нам, конечно, нужно будет складывать с промежуточной суммой. Иначе у нас не будет возможности получить общую сумму.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| с :1:46, и следуйте текстовым инструкциям1:46
Это две причины, по которым нам необходимо думать о времени. Но есть и другой вопрос, где нам, вообще-то, не хотелось бы думать о времени, но мы вынуждены должным образом заметать этот вопрос под коврик. Речь о том факте, что компьютеры работают с некоторой конечной скоростью, и нам нужно убедиться, что мы не требуем от компьютера выполнять вычисления быстрее, чем он может. Или, по крайней мере, знать, с какой скоростью может работать компьютер.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| с :2:14, и следуйте текстовым инструкциям2:14
Давайте посмотрим, каким образом мы будем решать все эти проблемы. В реальной жизни, в физическом мире, время — это непрерывная стрела времени. Время начинается с минус бесконечности или, возможно, с Большого взрыва, и продолжает течь секундами миллисекундами, микросекундами, пикосекундами. Возможно, деление доходит до конечного кванта времени — а может, и нет.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| с :2:36, и следуйте текстовым инструкциям2:36
Мы поступим так же, как поступают в компьютерных науках все: заменим непрерывное физическое время, которое очень сложно представить, — на дискретное. У нас будет так называемый тактовый генератор, это генератор прямоугольных импульсов с фиксированной частотой. И каждый его период мы будем рассматривать как одну единицу времени. Итак, у нас есть тактовый генератор, и он делит непрерывное физическое время на последовательность тактов: первый, второй, третий и так далее. В рамках каждого такта мы рассматриваем время как одну неделимую единицу. В пределах такта, это цельной единицы времени, ничего не меняется. Так, например, если у нас есть вентиль "НЕ", и мы посмотрим на его вход и выход, то в разные единицы времени у него могут быть разные значения на входе. И мы считаем, что выходное значение для этого входа элемент вычисляет в этой единице времени, мгновенно. Каждый такт вход может измениться, и выход следом тоже изменится. Посмотрите на эту схему: мы видим, что в первом такте на входе — 1. Выход, естественно 0, потому что так работает наш вентиль. Во втором такте вход меняется на 0. Он мог бы, например, и остаться 1, но если вход меняется на 0, выход мгновенно становится 1, и так далее.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| с :4:3, и следуйте текстовым инструкциям4:03
Таким способом в компьютерах и строится вся секвенциальная логика: последовательными временными тактами. И сейчас самое время замести под коврик вопрос задержек.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| с :4:18, и следуйте текстовым инструкциям4:18
Если посмотреть на реальный физический сигнал, на какую-то реализацию, например, на электрический сигнал, то он не мгновенно переходит в ноль между первым и вторым тактом, или между нулевым и первым тактом. На самом деле, ток нарастает постепенно — и напряжение, если мы представляем значение бита с его помощью, тоже меняется постепенно. И если мы посмотрим на то, как выглядит аналоговый сигнал внутри нашей реализации вентиля, то он будет иметь форму волны, похожую на изображённую здесь в первом такте: на достижение конечного значения уходит какое-то время.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| с :4:55, и следуйте текстовым инструкциям4:55
А затем требуется некоторое время и на то, чтобы выход достиг своего конечного значения. Вероятно, для выхода потребуется больше времени, чем для входа, из-за дополнительной задержки в самом вентиле. Весь смысл нашего логического подхода к делению времени на дискретные отрезки заключается в том, что мы не хотим задумываться об этих задержках. Если тактовый генератор работает не слишком быстро, и нам хватает времени между соседними тактами, мы можем игнорировать всё, происходящее в начале такта, всю эту серую зону на схеме. Если к концу серой зоны все сигналы достигают своих конечных состояний, то у нас всё в порядке. Более того, мы специально выбираем период тактового сигнала таким, чтобы гарантировать, что всё оборудование придёт в устойчивое состояние. Схемы должны завершить свои логические операции к концу серого блока, и такт должен быть лишь чуть дольше него. На самом деле, эти серые зоны будут везде, где меняется напряжение и система пытается установить новые логические состояния. А складывающаяся к концу цикла картина — это и есть наблюдаемое логическое состояние системы. Так что можно попросту игнорировать эти изменения, происходящие в серой зоне, потому что мы знаем, что они закончатся к концу такта. Таким образом мы и заметаем вопрос задержек под ковёр, тем самым оправдывая наше представление о времени как о серии дискретных шагов, следующих друг за другом. Мы пришли к тому, что у нас есть неделимые временные отрезки, и мы знаем, что в каждую отдельную единицу времени может что-либо произойти. С этой точки зрения, вся логика, о которой мы говорили в первой и второй лекции, является комбинационной. Там выход в момент времени t всецело зависит от входа в момент времени t. Теперь же информация переходит из момента t-1 в момент времени t. Когда мы говорим о секвенциальной логике, то подразумеваем, что информация на момент t, выход в момент времени t, — зависит от значения входа в момент времени t-1. Мы помним то, что было в прошлом периоде, и на основе значения входа из предыдущего такта вычисляем значение выхода в новом такте. Если мы посмотрим на схему с тактами 1, 2, 3, 4, то если на каком-то входе значениями становились a, b, c, d — а это может быть один бит или значения многоразрядной шины, — то в комбинационной логике в каждый момент времени значение "a" преобразовывалось согласно какой-то функции от "a". На втором такте выход был функцией от входного значения на том же втором такте. И в каждый момент времени были свои значения входа и выхода. В секвенциальной логике выходные данные на момент времени t зависят от входных данных в момент t-1, от предшествующих событий. В принципе, можно было бы добавить сюда и зависимость от происходящего в сам момент t, но лучше разделить эти два типа наших вычислений: комбинационную логику, срабатывающую моментально в пределах такта, от секвенциальной логики, где мы, как правило, не хотим смешивать новую информацию со старой. Так что мы просто считаем там, что состояние в момент времени t+1 зависит от входа в предыдущий момент времени t.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||| с :8:24, и следуйте текстовым инструкциям8:24
Глядя на вещи таким образом, можно прийти к весьма любопытному выводу: вход и выход могут быть одними и теми же битами в составе одних и тех же шин нашего оборудования. И мы можем назвать это состоянием. Если наше значение в момент времени t зависит от предыдущего значения на момент t-1, то мы можем удерживать эти значения в цепях нашей системы. Например, у нас может быть один бит, который хранит так называемое состояние. И если в такте 1 это значение было "a", то в такте 2 оно будет какой-то функцией от "а", f(a). В такте 3 оно будет функцией от функции от "a", f(f(a)), то есть, функцией от предыдущего значения, и так далее. Это впервые даёт нам возможность изменять состояние системы со временем, не запоминая, а вычисляя его на основе предыдущих результатов. На этом заканчивается наш обзор общепринятого подхода к пониманию абстракции времени в цифровых схемах. Суть в том, что мы просто разбиваем время на целочисленные временные шаги и наблюдаем последовательность изменений шаг за шагом, а не непрерывно. В следующей лекции мы рассмотрим элементы, которые позволят нам производить подобные операции.